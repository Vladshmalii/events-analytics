# ADR - Architectural Decision Records

## Рішення 1: Вибір веб-фреймворку

### Контекст
Потрібен веб-фреймворк для API, який підтримує високу пропускну здатність (100k+ events), асинхронність та швидку розробку.

### Варіанти
* **FastAPI**: Async з коробки, автогенерація OpenAPI, Pydantic валідація
  - Плюси: швидкість, async/await нативно, мала кількість boilerplate
  - Мінуси: менша екосистема, немає ORM з коробки
* **Django + DRF**: Повний стек, ORM, admin панель
  - Плюси: велика екосистема, багато готових рішень
  - Мінуси: overhead для API-only, повільніший, складніший async
* **Flask**: Легкий, гнучкий
  - Плюси: простота, мінімалізм
  - Мінуси: немає async з коробки, багато вручну налаштовувати

### Рішення
**FastAPI** - швидкість розробки + продуктивність. Async критичний для high-throughput API. Pydantic валідація out-of-the-box.

---

## Рішення 2: База даних для аналітики

### Контекст
Потрібна БД для аналітичних запитів (DAU, retention, top events) по мільйонах подій з високою швидкістю читання.

### Варіанти
* **PostgreSQL**: Універсальна SQL БД
  - Плюси: знайома, ACID, зріла
  - Мінуси: рядкове зберігання (повільно для аналітики), великий розмір даних
* **MongoDB**: NoSQL документна БД
  - Плюси: гнучка схема, горизонтальне масштабування
  - Мінуси: немає JOIN, агрегації повільніші за SQL
* **ClickHouse**: Колоночна OLAP БД
  - Плюси: колоночне зберігання (швидкі агрегації), компресія 10x, SQL-сумісний
  - Мінуси: немає UPDATE/DELETE, складніше налаштування

### Рішення
**ClickHouse** - запити швидші в 10-30 разів за PostgreSQL для аналітики. Колоночне зберігання ідеальне для COUNT/SUM/UNIQ. Benchmark показав 16x перевагу на DAU запитах.

---

## Рішення 3: База даних для дедуплікації

### Контекст
Потрібна персистентна дедуплікація подій по event_id з ACID гарантіями.

### Варіанти
* **Redis**: In-memory key-value
  - Плюси: швидкий lookup
  - Мінуси: обмеження пам'яті, ризик втрати даних
* **PostgreSQL**: Реляційна БД
  - Плюси: ACID транзакції, ON CONFLICT DO NOTHING, персистентність
  - Мінуси: трохи повільніший за Redis
* **ClickHouse ReplacingMergeTree**: Дедуплікація в ClickHouse
  - Плюси: одна БД для всього
  - Мінуси: дедуплікація не гарантована в реальному часі

### Рішення
**PostgreSQL** - надійність важливіша за швидкість для дедуплікації. ACID гарантує відсутність дублікатів.

---

## Рішення 4: Черга повідомлень

### Контекст
Потрібна асинхронна обробка подій з retry механізмом та dead letter queue.

### Варіанти
* **RabbitMQ**: Класичний message broker
  - Плюси: зріла екосистема, складні routing
  - Мінуси: складніше налаштування
* **Kafka**: Distributed streaming
  - Плюси: висока пропускна здатність (>50k events/sec)
  - Мінуси: складна архітектура, overkill для <10k events/sec
* **Redis + Celery**: In-memory черга
  - Плюси: простота, Celery багатий функціонал
  - Мінуси: менша throughput за Kafka

### Рішення
**Redis + Celery** - достатня продуктивність, мінімальна складність, Celery має retry/dead-letter з коробки.

---

## Рішення 5: Архітектура Hot/Cold

### Контекст
Зберігання подій для дедуплікації (швидкий доступ) та аналітики (великі обсяги).

### Варіанти
* **Тільки ClickHouse**: Все в одній БД
  - Плюси: простота
  - Мінуси: ReplacingMergeTree не гарантує real-time дедуплікацію
* **Hybrid (PostgreSQL + ClickHouse)**: Гарячий 7 днів + Холодний
  - Плюси: оптимізація для різних use cases, економія storage
  - Мінуси: складніша архітектура

### Рішення
**Hybrid** - PostgreSQL для дедуплікації та останніх 7 днів, ClickHouse для історії. Паралельний запис. Економія storage.

---

## Підсумок

Архітектура побудована з фокусом на простоту, продуктивність та надійність.